Réflexions métaphysiques

La seule véritable réalité c'est la perception présente de notre état mental qui contient les souvenirs de nos sensations et actions passées. Tout le reste est construction mentale. 
La perception est un transfert d'information d'une réalité perçue vers un esprit percevant. Elle suppose donc l'existence de l'esprit. 

Les informations que nous percevons ne sont pas aléatoires, elles présentent des régularités. Elles sont comme le développement d'un germe plus petit. 

C'est grâce à ces régularités qu'on peut construire un modèle mathématique du monde. 

La seule réalité étant la perception, l'existence de l'univers dépend de celle de l'esprit le percevant.
Quelle peut être la place et la nature de l'esprit dans un tel modèle ? 

Les physiciens ont découvert que les particules se comportent de façon probabiliste (physique quantique). 
Si la matière est constituée d'une infinité de niveaux imbriqués, tout modèle fini ne peut être qu'approximatif. Le réel est la limite d'une suite infinie de théories finies. 
Cela impliquerait donc que : 
* pour tout évènement physique, il existe une théorie physique assez précise pour prédire de quelle façon cet évènement se déroulera ;
* quel que soit le degré de précision atteint par une théorie, il resterait toujours une part d'inconnu, d'indétermination .
Le cerveau peut amplifier le comportement d'une particule au niveau de l'individu.
Le sentiment que la colonie de cellules appelée individu a de constituer une entité spirituelle monadique vient de l'énorme écart existant entre la forte connectivité interne et la relativement faible connectivité externe. 

Comment se fait-il que les lois de la physique soient exactement les bonnes pour permettre l'existence d'une extraordinaire complexité rendant possible l'apparition d'une vie intelligente? Il aurait suffi qu'elles soient très légèrement différentes pour qu'elles donnent naissance à un univers sans intérêt. C'est ce qu'on appelle le principe anthropique. Peut-on en conclure à l'existence d'un être suprême qui aurait délibérément choisi ces lois de façon à permettre l'apparition de l'homme? Ce n'est pas sûr. L'hypothèse des mondes multiples permet d'imaginer qu'il existe une infinité d'univers, un pour chaque ensemble de lois physiques possible. De plus elle permet d'expliquer le non déterminisme de la physique quantique sans recourir au hasard, en supposant que lors du collapse de la fonction d'onde l'univers se "ramifie". La notion de choix serait alors illusoire et l'éthique s'effondrerait si on ne lui conservait son sens en considérant que ce ne sont que des théories et que l'erreur est plus grave dans un sens que dans l'autre. Cette hypothèse, bien que plus complexe au niveau de son développement, est plus simple au niveau du " germe " qui l'engendre.

Pourquoi y a-t-il quelque chose et pas rien? Que se passerait-il s'il n'y avait rien? Seules les mathématiques existeraient car elles sont l'étude de rien. Il existerait donc des modèles mathématiques ainsi que des suites infinies convergentes de tels modèles. Une telle imbrication infinie pourrait alors engendrer un esprit qui la percevrait comme un monde dans lequel il vit. Ainsi il apparait que l'univers pourrait être engendré par le néant ou, dit autrement, que le véritable néant ne pourrait pas exister car il engendre nécessairement le tout. 

Cette idée a été pressentie par l'écrivain de science-fiction polonais Stanislas Lem dans la nouvelle intitulée "Profsor A. Donda" ("Le professeur A. Donda"). 

Cette hypothèse des univers mathématiques apporte un éclairage nouveau sur le non-déterminisme de la physique quantique lors de la collapse de la fonction d'onde et sur l'hypothèse des mondes multiples. 

L'arborescence de tous les mondes possibles serait prédéterminée mais le fait que nous ne percevons qu'une ramification nous la ferait percevoir comme choisie par notre libre arbitre.

La dissymétrie du temps pourrait venir du fait que le point de fixation le plus proche (Big Bang) est situé dans le passé, les perturbations se propageant dans la direction opposée. 

Le plaisir est le moyen utilisé par la nature pour nous conduire à réaliser ses buts. 

Logique combinatoire symbolique
et application à une logique résistante aux propositions p=~p 
* Notations : 
* abc=(ab)c 
* (pt x.a=b) = (lambda x. a = lambda x. b) 
* lambda x. x = I 
* lambda x. y = K y si y ne contient pas x 
* lambda x. (a b) = S (lambda x.a) (lambda x. b) 
* lambda x. (f x) = f 
* Axiomes : 
* a=b -> b=a 
* a=b, b=c -> a=c 
* f=g, a=b -> fa=gb 
* I=I 
* K=K 
* S=S 
* Z=Z 
* a=a' -> Ia=a' 
* a=a', b=b' -> Kab=a' 
* a=a', b=b', c=c' -> Sabc=a'c'(b'c') 
* Une logique permettant de manipuler des propositions p=~p : 
* Idée : distinguer l'affirmation d'une implication p=!>q (si on a pu démontrer p, alors on peut affirmer q) et l'interrogation p=?>q (en faisant l'hypothèse p, on peut démontrer q) 
* axiomes : 
* Modus ponens : p=!>q, p -> q 
* p =?> p 
* p =!> (q =?> p) 
* (p =?> (q =!> r) ) =!> ((p =?> q) =!> (p =?> r)) - on peut appliquer le modus ponens sous l'hypothèse p 
* Représentation en logique combinatoire : 
* Les propositions sont des égalités a=b 
* a=b =*> c=d est représenté par E* a b c = E* a b d 
* ~(a=b) est représenté par E! a b K = E! a b (K I) ou E? a b K = E? a b (K I) 
* les axiomes deviennent : 
* Modus ponens : S E! I = K I ou E! a a b = b 
* pt a. pt b. (E? a b a = E? a b b) 
* le troisième axiome devient inutile 
* pt a. pt b. pt f. pt x. (E? a b (f x) = E? a b f (E? a b x)) 

Divers formalismes logiques

        0       : faux
        p =!> q : q -> p
        p =?> q : hyp [aj(aff(p) q]

        aff (A /\ B) : aff A; aff B
        test (A /\ B) : test A; test B

        aff (A \/ B) : faux -> hyp [aj(aff A) faux] hyp [aj(aff B) faux]
                        ((A =?> 0) /\ (B =?> 0)) =!> 0
        test (A \/ B) : hyp [aj (faux->test A aj (faux->test B) faux]
                        ((A =!> 0) /\ (B =!> 0)) =?> 0

        p \?/ q : (p =!> 0) =?> (q =!> 0) =?> 0
        Pour tout r (p =!> r) =?> (q =!> r) =?> r

        aff (~A) : faux -> test A
                   A =!> 0
        test (~A) : hyp [aj(aff A) faux]
                    A =?> 0

        A => B = ~A \/ B = ~(A /\ ~B)
        
        aff (A => B) : faux -> test A; hyp [aj (aff B) faux]
                        (A /\ (B =?> 0)) =!> 0
                        ~! (A /\ ~?B)

        test (A => B) : hyp [aj (aff A); aj (faux->test B); faux]
                        A =?> (B=!>0) =?> 0
                        (A /\ (B =!> 0)) =?> 0
                        ~? (A /\ ~!B)

        notation : [x] = pour tout x
                   <x> = il existe x

        aff ([x] Ax) : faux -> soit(x) hyp [aj (aff (Ax)) faux]

        test ([x] Ax) : hyp [objet(x) Ax]

        aff (<x> px) : creer(x) aff(px)

        test (<x> px) : hyp [aj (faux->soit(x) test(px) faux]


        ext
        reg fond
        infini
        
        <w> [y] (~y:w /\ <x> (w:x
                [z] (z:x => <v> v:x /\ v = z U {z} ou v > z U {z}

        v > z U {z} z:v /\ [u] u:z =>

        <w> [y] (~y:w & [x] (x:w
        <z> (z:x /\ [v] ...

        <w> [y] (~y:N  (w:x) 1
        [z] (z:x => <v> (v:x 1

        <w> [y] (y:w /\ [x] (w
        <z> (z:x [v]
        <w>

                y =/= x
        ext     y ([z] (z:x <=> z:y) => x=y)

        regfond <y> y:x

        paire   [xy] <z> [t] (t:z <=> t=x \/ t=y)

        union   [x] <y> [z] (z:y <=> <t> (t:x /\ z:t))

        parties [x] <y> [z] (z:y <=> [t] (t:z => t:x))
                                             z=x

        infini  <x> (0:x /\ [y] (y:x => y U {y} : x))

                [x1...xk] [x] <y> [z] (z:y => z:x /\ A(z,x1,...,xk))
                
                [x1...xk] [x] <yz> (z:y => <u> (u:x /\ A(u,z,x1,...,xk))


                        <-> z:y) -> x=y

                        <y> y:x
                <y> y:x & ~<z> (z:x & z:y)

                [z] <y> [x] (x:y <=> x:z & PHI(x))

        power set
                <x> [y] (x:y <-> [z] (z:x -> z:w)

        infinity        w [y] (~y:z & [x] (x:w -> 
                                <z> (z:w & [u] (u:z <-> v=z \/ v:z))
                                        u=x \/ u:x

        regl    [xyz] PHI(x,y) & PHI(x,z) ->
                <w> [y] (y:w => <x> x:z & PHI(x,y)

        sum     <y> [x] (x

        empty   <y> [x] ~x:y

        pair    <y> [x] (x:y <-> x:z \/ x:t)

        infini  <x> (0:x /\ [y] (y:x
                        y U {y} : x)


        dem (dA, dB)
        prop (pA, pB)

        subst (p, x, q)
        ~<d> dem (d, p) subst (u, u, p)  u variable libre
        -> nombre f
        subst (f, f, g)  g -> G
        x : ~<d> dem (d, g) /\ subst (f, f, p)

        consis : ~ <d>
        phi rep "0 = 1"

        |- (~G) => (~consis

        |- ~G
        |- <d> dem (d, g)
     -> |- <d'> dem (d', "<d> dem
                avec "n" = proposition representee par n
     -> |- <d'> dem (d',~g)
     -> |- <d''> dem (d'', g/\~g)
           <d'''> dem (d''', phi)
     avec ~p = {~
          p/\q = "{p} /\ {q}"

                => ~consis)
                consis => G
          |- consis A => consis B
          theories A et B
          demonstrations
          transdem
          transprop

          A U |- consis A
          A U consis A U consis (A U consis A)
          ...
          ordinaux

                n (<d> dem
          => [n] p(n)
          cas particulier P = Kq
          <d> dem (d, "q") => q
          cas particulier q = (0 = 1)
          -> |- consis

          [r] r rep comb =>
          <d> (rep dem) dem (d, "
          .=>, a=b

          A
          -> A U |- ([n] 
                     <d> dem (d, <p
                     => ([n] p(n))

          cas particulier "v bidon"

          ord
          etape 1 -> regle omega

Ordinaux transfinis

        suc p
        n) 0 = A n (suc 0)
        suc n) (suc p) =
        suc : A n : A (suc n) p

\0 (n) = n
\(x+1) (n) = \x (n+1)
\Ux (n) = xn (n)


        > x
        > Hf(fx)
H' phi f x = phi x U phi (f x) U phi (f (f x)) U ...
        > phi x
        > H' phi f (f x)

        x *> y <=> x >= y
        x *> y et y *> x : y ~= x
        x *> suc y <=> x > y

        x : Omega
        0 : Omega
        x : Omega => suc x : Omega
        x1, x2, ... : Omega : 0 x1 : Omega

0
1 = suc 0
2 = suc (suc 0) ...
omega = H suc 0
omega + 1 = suc (H suc 0) ...
omega * 2 = H suc (H suc 0)
omega ** 2 = H (H suc) 0
omega ** omega = H H suc 0
epsilon 0 = R1 H suc 0 = H ... H suc 0
        H R1 H suc 0
        R1 H R1 H suc 0
        R2 R1 H suc 0
        R3 R2 R1 H suc 0 = R(3->1) H suc 0
        ...
        R(x->1) H suc 0

x = H [R(|->1) H suc 0] 0       avec [f|] = \x.fx
x = R(x->1) H suc 0
x = [[[H [R(|->1) |... |.. |.] 0]]] H suc 0
  = R(1;1) H suc 0
  ... R2 R(1;1) H suc 0
  
















